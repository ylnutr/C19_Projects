---
title: "Spatial Analysis with Custom Genome"
author: "Yujin L"
date: "`r Sys.Date()`"
output: html_document
---

## 1 Load packages

Besides Seurat, we need to import some useful packages.

dplyr and ggplot2 are part of tidyverse, a readable and flexible R language for solving data science challenges. I personally prefer the coding style with tidyverse, but you may use base R too. patchwork combines separate ggplots into the same graphic with easy access to control layouts. limma is a Bioconductor package to analyze microarray data. It is not essential for our analysis, but may provide a more efficient implementation of the Wilcoxon rank sum test in differential expression analysis.


```{r library, echo=TRUE, warning=TRUE}
library(tidyverse)
library(Seurat)
library(dplyr) # data manipulation
library(ggplot2)
library(patchwork)
library(clustree)
library(SingleCellExperiment)
library(SingleR)
library(celldex)
library(scRNAseq)
library(pheatmap)
library(scran)
library(viridis)
library(ggforce)
library(gghalves)
library(ggridges)
library(scDblFinder)
library(cluster)
library(bluster)
```
Load Data
```{r loadrdata, echo=TRUE, warning=TRUE}
load("/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/05.Analysis_in_R/Analysis_in_R.RData")
```

##2. Create Seurat Objectrm
We first load one spatial transcriptomics dataset into Seurat at a time and then explore the Seurat object a
bit.
#2.1 Load 12 10X Genomics Visium dataset into Seurat
A spatial gene expression dataset of mouse distal colon and tumor tissue collected by Space Ranger 2.0.0. will
be analyzed throughout the tutorial. Both the gene expression matrix and spatial imaging data are
necessary for the computational analysis.
The data files we will be using today include:
- a (filtered) feature / cell matrix HDF5 file (.h5)
- a spatial imaging data folder (.tar.gz)

```{r load, echo=TRUE, warning=TRUE}
E296_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/E296_C-A1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "CR_1", filter.matrix = TRUE, to.upper = FALSE)
C507_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C507_A-A1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "ACR_1", filter.matrix = TRUE, to.upper = FALSE)
C569_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C569_C-B1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "ACR_2", filter.matrix = TRUE, to.upper = FALSE)
C822_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C822_C-C1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_1", filter.matrix = TRUE, to.upper = FALSE)
C498_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C498_A-B1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_2", filter.matrix = TRUE, to.upper = FALSE)
C583_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C583_A-C1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_3", filter.matrix = TRUE, to.upper = FALSE)
C531_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C531_A-D1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_4", filter.matrix = TRUE, to.upper = FALSE)
C520_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C520_B-A1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_5", filter.matrix = TRUE, to.upper = FALSE)
C522_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C522_B-B1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_6", filter.matrix = TRUE, to.upper = FALSE)
C565_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C565_C-D1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "ACR_TU1", filter.matrix = TRUE, to.upper = FALSE)
C515_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C515_B-C1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "ACR_TU2", filter.matrix = TRUE, to.upper = FALSE)
C533_data <- Seurat::Load10X_Spatial(
  data.dir = "/stor/work/Fleet/BCG/2024_04.Fleet_visium_customgenome/02.count/C533_B-D1/outs/",
  filename = "filtered_feature_bc_matrix.h5", assay = "Spatial", slice = "AKCR_TU1", filter.matrix = TRUE, to.upper = FALSE)
```

View each dataset

```{r dataview, echo=TRUE, warning=TRUE}
E296_data
C507_data
C569_data
C822_data
C498_data
C583_data
C531_data
C520_data
C522_data
C565_data
C515_data
C533_data
```
## 3 Preprocess data
# 3.1. Quality control
A few common QC metrics include

- The number of unique genes detected in each sample (nFeature_Spatial).
- The total number of molecules detected within a sample (nCount_Spatial).
- The percentage of reads that map to the mitochondrial genome (percent.mt).

```{r qcmetrics, echo=TRUE, warning=TRUE}
E296_data[["percent.mt"]] <- PercentageFeatureSet(E296_data, pattern = "^mt-")
VlnPlot(
  E296_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C507_data[["percent.mt"]] <- PercentageFeatureSet(C507_data, pattern = "^mt-")
VlnPlot(
  C507_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C569_data[["percent.mt"]] <- PercentageFeatureSet(C569_data, pattern = "^mt-")
VlnPlot(
  C569_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C822_data[["percent.mt"]] <- PercentageFeatureSet(C822_data, pattern = "^mt-")
VlnPlot(
  C822_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C498_data[["percent.mt"]] <- PercentageFeatureSet(C498_data, pattern = "^mt-")
VlnPlot(
  C498_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C583_data[["percent.mt"]] <- PercentageFeatureSet(C583_data, pattern = "^mt-")
VlnPlot(
  C583_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C531_data[["percent.mt"]] <- PercentageFeatureSet(C531_data, pattern = "^mt-")
VlnPlot(
  C531_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C520_data[["percent.mt"]] <- PercentageFeatureSet(C520_data, pattern = "^mt-")
VlnPlot(
  C520_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C522_data[["percent.mt"]] <- PercentageFeatureSet(C522_data, pattern = "^mt-")
VlnPlot(
  C522_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C565_data[["percent.mt"]] <- PercentageFeatureSet(C565_data, pattern = "^mt-")
VlnPlot(
  C565_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C515_data[["percent.mt"]] <- PercentageFeatureSet(C515_data, pattern = "^mt-")
VlnPlot(
  C515_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
C533_data[["percent.mt"]] <- PercentageFeatureSet(C533_data, pattern = "^mt-")
VlnPlot(
  C533_data, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt"), 
  pt.size = 0.1, ncol = 3) & 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```
```{r subsetting, echo=TRUE, warning=TRUE}
E296_subset <- subset(E296_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(E296_data) - ncol(E296_subset), 
            "samples because of the outlier QC metrics, with", ncol(E296_subset), "samples left."))
C507_subset <- subset(C507_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C507_data) - ncol(C507_subset), 
            "samples because of the outlier QC metrics, with", ncol(C507_subset), "samples left."))
C569_subset <- subset(C569_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C569_data) - ncol(C569_subset), 
            "samples because of the outlier QC metrics, with", ncol(C569_subset), "samples left."))
C822_subset <- subset(C822_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C822_data) - ncol(C822_subset), 
            "samples because of the outlier QC metrics, with", ncol(C822_subset), "samples left."))
C498_subset <- subset(C498_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C498_data) - ncol(C498_subset), 
            "samples because of the outlier QC metrics, with", ncol(C498_subset), "samples left."))
C583_subset <- subset(C583_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C583_data) - ncol(C583_subset), 
            "samples because of the outlier QC metrics, with", ncol(C583_subset), "samples left."))
C531_subset <- subset(C531_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C531_data) - ncol(C531_subset), 
            "samples because of the outlier QC metrics, with", ncol(C531_subset), "samples left."))
C520_subset <- subset(C520_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C520_data) - ncol(C520_subset), 
            "samples because of the outlier QC metrics, with", ncol(C520_subset), "samples left."))
C522_subset <- subset(C522_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C522_data) - ncol(C522_subset), 
            "samples because of the outlier QC metrics, with", ncol(C522_subset), "samples left."))
C565_subset <- subset(C565_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C565_data) - ncol(C565_subset), 
            "samples because of the outlier QC metrics, with", ncol(C565_subset), "samples left."))
C515_subset <- subset(C515_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C515_data) - ncol(C515_subset), 
            "samples because of the outlier QC metrics, with", ncol(C515_subset), "samples left."))
C533_subset <- subset(C533_data, subset = nCount_Spatial > 1500 & percent.mt < 20)
print(paste("Filter out", ncol(C533_data) - ncol(C533_subset), 
            "samples because of the outlier QC metrics, with", ncol(C533_subset), "samples left."))
```
# 3.2. Gene Expression Visualization
The SpatialFeaturePlot() function in Seurat extends FeaturePlot(), and can overlay molecular data on top of tissue histology. I used this feature to see the subsetted out spots overlayed on tissue image.
```{r postqcview,fig.height=8, echo=TRUE, warning=TRUE}
plot1 <- SpatialFeaturePlot(
  E296_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("E296_subset")
plot2 <- SpatialFeaturePlot(
  C507_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C507_subset")
plot3 <- SpatialFeaturePlot(
  C569_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C569_subset")
plot4 <- SpatialFeaturePlot(
  C822_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C822_subset")
plot5 <- SpatialFeaturePlot(
  C498_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C498_subset")
plot6 <- SpatialFeaturePlot(
  C583_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C583_subset")
plot7 <- SpatialFeaturePlot(
  C531_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C531_subset")
plot8 <- SpatialFeaturePlot(
  C520_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C520_subset")
plot9 <- SpatialFeaturePlot(
  C522_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C522_subset")
plot10 <- SpatialFeaturePlot(
  C565_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C565_subset")
plot11 <- SpatialFeaturePlot(
  C515_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C515_subset")
plot12 <- SpatialFeaturePlot(
  C533_subset, features = c("nFeature_Spatial", "nCount_Spatial", "percent.mt")) &
  theme(legend.position = "right") & ggtitle("C533_subset")
plot1
plot2
plot3
plot4
plot5
plot6
plot7
plot8
plot9
plot10
plot11
plot12
```

# 3.3 Normalization and Re-labeling

The variance of molecular counts expresses spatial heterogeneity which cannot be solely explained by technical noise. Satija Lab and Collaborators recommends normalization using SCTransform (Hafemeister and Satija, 2019) in order to account for technical bias while preserving true biological differences. We will also change the "orig.ident" of each sample to unique sample number (genotype+number, e.g. AKCR_3). By changing their orig.ident to unique names, we can still call up a single sample when they are pooled.
```{r norm, echo=TRUE, warning=TRUE}
E296_norm <- SCTransform(E296_subset, assay = "Spatial", verbose = FALSE)
C507_norm <- SCTransform(C507_subset, assay = "Spatial", verbose = FALSE)
C569_norm <- SCTransform(C569_subset, assay = "Spatial", verbose = FALSE)
C822_norm <- SCTransform(C822_subset, assay = "Spatial", verbose = FALSE)
C498_norm <- SCTransform(C498_subset, assay = "Spatial", verbose = FALSE)
C583_norm <- SCTransform(C583_subset, assay = "Spatial", verbose = FALSE)
C531_norm <- SCTransform(C531_subset, assay = "Spatial", verbose = FALSE)
C520_norm <- SCTransform(C520_subset, assay = "Spatial", verbose = FALSE)
C522_norm <- SCTransform(C522_subset, assay = "Spatial", verbose = FALSE)
C565_norm <- SCTransform(C565_subset, assay = "Spatial", verbose = FALSE)
C515_norm <- SCTransform(C515_subset, assay = "Spatial", verbose = FALSE)
C533_norm <- SCTransform(C533_subset, assay = "Spatial", verbose = FALSE)
```
```{r changeorigident, echo=TRUE, warning=TRUE}
E296_subset$orig.ident <- "CR_1"
C507_subset$orig.ident <- "ACR_1"
C569_subset$orig.ident <- "ACR_2"
C822_subset$orig.ident <- "AKCR_1"
C498_subset$orig.ident <- "AKCR_2"
C583_subset$orig.ident <- "AKCR_3"
C531_subset$orig.ident <- "AKCR_4"
C520_subset$orig.ident <- "AKCR_5"
C522_subset$orig.ident <- "AKCR_6"
C565_subset$orig.ident <- "ACR_TU1"
C515_subset$orig.ident <- "ACR_TU2"
C533_subset$orig.ident <- "AKCR_TU1"
E296_norm$orig.ident <- "CR_1"
C507_norm$orig.ident <- "ACR_1"
C569_norm$orig.ident <- "ACR_2"
C822_norm$orig.ident <- "AKCR_1"
C498_norm$orig.ident <- "AKCR_2"
C583_norm$orig.ident <- "AKCR_3"
C531_norm$orig.ident <- "AKCR_4"
C520_norm$orig.ident <- "AKCR_5"
C522_norm$orig.ident <- "AKCR_6"
C565_norm$orig.ident <- "ACR_TU1"
C515_norm$orig.ident <- "ACR_TU2"
C533_norm$orig.ident <- "AKCR_TU1"
```

## 4. Merge samples

This dataset contains multiple slices of samples That needs to be merged and integrated into a single large Seurat object. Here we use the merge function.

```{r pool, echo=TRUE, warning=TRUE}
spatial_pooled <- merge(x = E296_norm, y = c(C507_norm, C569_norm, C822_norm, C498_norm, C583_norm, C531_norm, C520_norm, C522_norm, C565_norm, C515_norm, C533_norm))
DefaultAssay(spatial_pooled) <- "SCT"
VariableFeatures(spatial_pooled) <- c(VariableFeatures(E296_norm), VariableFeatures(C507_norm), VariableFeatures(C569_norm), VariableFeatures(C822_norm), VariableFeatures(C498_norm), VariableFeatures(C583_norm), VariableFeatures(C531_norm), VariableFeatures(C520_norm), VariableFeatures(C522_norm), VariableFeatures(C565_norm), VariableFeatures(C515_norm), VariableFeatures(C533_norm))
spatial_obj <- RunPCA(spatial_pooled, verbose = FALSE)
spatial_obj <- FindNeighbors(spatial_obj, dims = 1:30)
spatial_obj <- FindClusters(spatial_obj, verbose = FALSE)
spatial_obj <- RunUMAP(spatial_obj, dims = 1:30)
```
```{r pooledplot, echo=TRUE, warning=TRUE}
plot13 <- DimPlot(spatial_539, reduction = "umap", group.by = c("ident", "orig.ident"), label = TRUE) 
plot14 <- SpatialDimPlot(spatial_539, label = TRUE, label.size = 3, ncol = 4)
plot13
plot14
```



```{r plots, echo=TRUE, warning=TRUE}
plot15 <- DimPlot(spatial_obj, reduction = "pca", group.by = c("SCT_snn_res.0.8", "orig.ident"), label = TRUE) 
plot15
```
# 4.1. Correcting for batch effects(ex. different sequencing depth)

 The 10X Visium samples I am working on consists of 9 distal colon Swiss roll samples from CR (n=1), ACR (n=2), and AKCR (n=6), and 3 tumor samples from ACR (n=2) and AKCR (n=1). I generated four more 10X Visium samples on March 2024 to integrate with eight samples that I generated on March 2023. However, before going into the sequencing run, the UT GSAF core did not have other samples to fill the run. To finish processing the samples quicker, I had to bump up the coverage and aim for about 700 million reads in total four samples, whereas the samples generated on March 2023 had the same amount of sequencing reads in total eight samples. As a result, when I used spaceranger aggr(pipeline from spaceranger to integrate 10X samples) to integrate my samples, There was an alert on the web summary page stating that the post-normalization read depth was low. I am not worried about the reads I'm losing due to subsampling, as there was enough coverage in the sample that had the lowest read depth. 
 
 When combining data from multiple capture areas, the spaceranger aggr pipeline automatically equalizes the read depth between groups before merging, which is the recommended approach in order to avoid the batch effect introduced by sequencing depth.  I checked if there was same (or similar) function offered in Seurat, as I had to manipulate Visium samples using Seurat to move onto further analyses. However, initially, I could only find applying sctransform(Hafemeister and Satija, Genome Biology 2019) normalization, which claims to build regularized negative binomial models of gene expression in order to account for technical artifacts while preserving biological variance. SCTransform does this by three steps: 
 
 -1. a negative binomial generalized linear model is used to fit each gene with observed total UMI count in a cell (a proxy for sequencing depth) as a covariate. 
 -2. each model parameter, including the intercept, slope, and negative binomial dispersion parameters, is regularized based on the relationship between parameter values and gene mean, to avoid overfitting. 
 -3. the regularized parameters are used to define an affine function using the negative binomial model to transform observed UMI counts into Pearson residuals.
 
 This is helpful normalizing within the sample. However, it did not seem to correct the batch effect shown with this graph below:
 
```{r sct_counts, echo=TRUE, warning=TRUE}
plot <- VlnPlot(spatial_obj, group.by = c("orig.ident"), features = c("nCount_SCT", "eGFP"), pt.size = 0.1, ncol = 1)
plot
```
As we can see in "nCount_SCT" plot above, The samples that were sequenced with higher read depths (CR_1, ACR_2, AKCR_1, ACR_TU1) had higher counts than other samples, which indicated that there were still some batch effects remaining. While searching, I found PrepSCTFindMarkers function, which was used in a merged object with multiple SCT models. This function uses minimum of the median UMI (calculated using the raw UMI counts) of individual objects to reverse the individual SCT regression model using minimum of median UMI as the sequencing depth covariate. The counts slot of the SCT assay is replaced with recorrected counts and the data slot is replaced with log1p of recorrected counts.

```{r prepsctfindmarkers, echo=TRUE, warning=TRUE}
spatial_pooled <- merge(x = E296_norm, y = c(C507_norm, C569_norm, C822_norm, C498_norm, C583_norm, C531_norm, C520_norm, C522_norm, C565_norm, C515_norm, C533_norm))
DefaultAssay(spatial_pooled) <- "SCT"
spatial_pooled <- PrepSCTFindMarkers(spatial_pooled, assay = "SCT", verbose = TRUE)
VariableFeatures(spatial_pooled) <- c(VariableFeatures(E296_norm), VariableFeatures(C507_norm), VariableFeatures(C569_norm), VariableFeatures(C822_norm), VariableFeatures(C498_norm), VariableFeatures(C583_norm), VariableFeatures(C531_norm), VariableFeatures(C520_norm), VariableFeatures(C522_norm), VariableFeatures(C565_norm), VariableFeatures(C515_norm), VariableFeatures(C533_norm))
plot <- VlnPlot(spatial_obj, group.by = c("orig.ident"), features = c("nCount_SCT", "eGFP"), pt.size = 0.1, ncol = 1)
plot
```

Let’s look at the distribution of number of transcripts and expressed genes per cell by sample.

```{r pooledplot3, echo=TRUE, warning=TRUE}
temp_labels <- spatial_obj@meta.data %>%
  group_by(orig.ident) %>%
  tally()

p1 <- ggplot() +
  geom_half_violin(
    data = spatial_obj@meta.data, aes(orig.ident, nCount_Spatial, fill = orig.ident),
    side = 'l', show.legend = FALSE, trim = FALSE
  ) +
  geom_half_boxplot(
    data = spatial_obj@meta.data, aes(orig.ident, nCount_Spatial, fill = orig.ident),
    side = 'r', outlier.color = NA, width = 0.4, show.legend = FALSE
  ) +
  geom_text(
    data = temp_labels,
    aes(x = orig.ident, y = -Inf, label = paste0('n = ', format(n, big.mark = ',', trim = TRUE)), vjust = -1),
    color = 'black', size = 2.8
  ) +
  scale_y_continuous(labels = scales::comma, expand = c(0.08,0)) +
  theme_bw() +
  labs(x = '', y = 'Number of transcripts') +
  theme(
    panel.grid.major.x = element_blank(),
    axis.title.x = element_blank()
  )

p2 <- ggplot() +
  geom_half_violin(
    data = spatial_obj@meta.data, aes(orig.ident, nFeature_Spatial, fill = orig.ident),
    side = 'l', show.legend = FALSE, trim = FALSE
  ) +
  geom_half_boxplot(
    data = spatial_obj@meta.data, aes(orig.ident, nFeature_Spatial, fill = orig.ident),
    side = 'r', outlier.color = NA, width = 0.4, show.legend = FALSE
  ) +
  geom_text(
    data = temp_labels,
    aes(x = orig.ident, y = -Inf, label = paste0('n = ', format(n, big.mark = ',', trim = TRUE)), vjust = -1),
    color = 'black', size = 2.8
  ) +
  scale_y_continuous(
    name = 'Number of expressed genes',
    labels = scales::comma, expand = c(0.08,0)
  ) +
  theme_bw() +
  theme(
    panel.grid.major.x = element_blank(),
    axis.title.x = element_blank()
  )
p1
p2
```

We can observe that the merged samples that went through sctfindmarker function has similar counts matrix now, which shows that the batch effect was corrected.
Principal component analysis was next performed, and principal components selected for using in later analyses.

```{r dimentionality resuction, echo=TRUE, warning=TRUE}
spatial_obj <- RunPCA(spatial_pooled, verbose = FALSE)
#Principal component loadings for top genes for the first 2 principal components. The loading can be interpreted as the weights for each original variable when calculating the principal components.
VizDimLoadings(spatial_obj, dims = 1:2, reduction = "pca")
#Heatmaps of the top 20 PCs. Cells and features are ordered according to their PCA scores and the 500 most extreme cells are selected to be shown in these plots.
DimHeatmap(spatial_obj, dims = 1:20, cells = 500, balanced = TRUE)
#Elbow plot for top principal components. Generally, PCs are used for further analysis which capture the majority of the variation seen in the data (before the elbow which is seen once the standard deviation associated with the PCs becomes small and does not change much between PCx and PCx+1.
ElbowPlot(spatial_obj, ndims = 40)
```
Based on this plot, we could roughly determine the majority of the variation by where the elbow occurs (touches the ground) to be between PC17-PC20. Determine percent of variation associated with each PC. While this gives us a good rough idea of the number of PCs needed to be included, a more quantitative approach may be a bit more reliable. We can calculate where the principal components start to elbow by taking the larger value of:

The point where the principal components only contribute 5% of standard deviation and the principal components cumulatively contribute 90% of the standard deviation.
The point where the percent change in variation between the consecutive PCs is less than 0.1%.
We will start by calculating the first metric:

```{r firstmetric, echo=TRUE, warning=TRUE}
pct <- spatial_obj[["pca"]]@stdev / sum(spatial_obj[["pca"]]@stdev) * 100
# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```
The first metric returns PC41 as the PC matching these requirements. Let’s check the second metric, which identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%:

```{r secondmetric, echo=TRUE, warning=TRUE}
# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
# last point where change of % of variation is more than 0.1%.
co2
```
This second metric returns PC18. Usually, we would choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.

```{r minmetric, echo=TRUE, warning=TRUE}
# Minimum of the two calculation
pcs <- min(co1, co2)
pcs
```
```{r clustering, echo=TRUE, warning=TRUE}
spatial_obj <- FindNeighbors(spatial_obj, dims = 1:10)
spatial_obj <- FindClusters(spatial_obj, verbose = FALSE)
spatial_obj <- RunUMAP(spatial_obj, dims = 1:10)
order <- c("CR_1","ACR_1","ACR_2","AKCR_1","AKCR_2","AKCR_3","AKCR_4","AKCR_5", "AKCR_6", "ACR_TU1", "ACR_TU2", "AKCR_TU1")
spatial_obj[["orig.ident"]] <- factor(x = spatial_obj@meta.data$orig.ident, levels = order)
```


Now we rerun the same plots we created to see the UMAP and SpatialDimPlot, which is UMAP overlayed on top of sample images.

```{r pooledplot2, echo=TRUE, warning=TRUE}
plot13 <- DimPlot(spatial_obj, reduction = "umap", group.by = c("ident", "orig.ident"), label = TRUE) 
plot14 <- SpatialDimPlot(spatial_obj, label = TRUE, label.size = 3, ncol = 3)
plot13
plot14
```

```{r pooledplot3, echo=TRUE, warning=TRUE}
plot15 <- DimPlot(spatial_obj, reduction = "pca", group.by = c("SCT_snn_res.0.9", "orig.ident"), label = TRUE) 
plot15
```



## 5. Clustering

Overfitting and underfitting are common problems in machine learning and can impact the performance of a model. Overfitting occurs when the model is too complex and fits the training data too closely. This leads to poor generalization. Underfitting happens when a model is too simple leading to poor performance. Here, I first identify clusters of cells by a shared nearest neighbor (SNN) modularity optimization-based clustering algorithm. First calculate k-nearest neighbors and construct the SNN graph. Then optimize the modularity function to determine clusters. In this part, I aim to seek the best resolution to cluster the transcriptomic profile of spatial data based on transcriptional similarity by using multiple resolutions.

```{r multiresolution, echo=TRUE, warning=TRUE}
resolution_values <- c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3)
spatial_obj <- FindClusters(spatial_obj, assay = "SCT", resolution = resolution_values)
plot16 <- clustree(spatial_obj, prefix = "SCT_snn_res.")
plot16
```


```{r umapindividualsamplessave, echo=TRUE, warning=TRUE}
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = "SCT_snn_res.0.4", split.by = "orig.ident", label = TRUE, ncol = 3, label.size = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/umappersample0.4.png", height = 3000, width = 2500, res = 300)
print(plot)
dev.off()
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = "SCT_snn_res.0.5", split.by = "orig.ident", label = TRUE, ncol = 3, label.size = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/umappersample0.5.png", height = 3000, width = 2500, res = 300)
print(plot)
dev.off()
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = "SCT_snn_res.0.6", split.by = "orig.ident", label = TRUE, ncol = 3, label.size = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/umappersample0.6.png", height = 3000, width = 2500, res = 300)
print(plot)
dev.off()
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = "SCT_snn_res.0.7", split.by = "orig.ident", label = TRUE, ncol = 3, label.size = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/umappersample0.7.png", height = 3000, width = 2500, res = 300)
print(plot)
dev.off()
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = "SCT_snn_res.0.8", split.by = "orig.ident", label = TRUE, ncol = 3, label.size = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/umappersample0.8.png", height = 3000, width = 2500, res = 300)
print(plot)
dev.off()
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = "SCT_snn_res.0.9", split.by = "orig.ident", label = TRUE, ncol = 3, label.size = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/umappersample0.9.png", height = 3000, width = 2500, res = 300)
print(plot)
dev.off()
```
```{r spatialumapindividualsamplessave, echo=TRUE, warning=TRUE}
plot <- SpatialDimPlot(spatial_obj, group.by = "SCT_snn_res.0.4", label = TRUE, label.size = 3, ncol = 3)
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/spatialumapres0.4.png", height = 8000, width = 6000, res = 300)
print(plot)
dev.off()
plot <- SpatialDimPlot(spatial_obj, group.by = "SCT_snn_res.0.5", label = TRUE, label.size = 3, ncol = 3)
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/spatialumapres0.5.png", height = 8000, width = 6000, res = 300)
print(plot)
dev.off()
plot <- SpatialDimPlot(spatial_obj, group.by = "SCT_snn_res.0.6", label = TRUE, label.size = 3, ncol = 3)
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/spatialumapres0.6.png", height = 8000, width = 6000, res = 300)
print(plot)
dev.off()
plot <- SpatialDimPlot(spatial_obj, group.by = "SCT_snn_res.0.7", label = TRUE, label.size = 3, ncol = 3)
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/spatialumapres0.7.png", height = 8000, width = 6000, res = 300)
print(plot)
dev.off()
plot <- SpatialDimPlot(spatial_obj, group.by = "SCT_snn_res.0.8", label = TRUE, label.size = 3, ncol = 3)
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/spatialumapres0.8.png", height = 8000, width = 6000, res = 300)
print(plot)
dev.off()
plot <- SpatialDimPlot(spatial_obj, group.by = "SCT_snn_res.0.9", label = TRUE, label.size = 3, ncol = 3)
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/spatialumapres0.9.png", height = 8000, width = 6000, res = 300)
print(plot)
dev.off()
```


```{r clustreeumap, echo=TRUE, warning=TRUE}
plot <- DimPlot(spatial_obj, reduction = "umap", group.by = c("SCT_snn_res.0.4", "SCT_snn_res.0.5", "SCT_snn_res.0.6", "SCT_snn_res.0.7", "SCT_snn_res.0.8", "SCT_snn_res.0.9"), label = TRUE, pt.size = 0.5, ncol = 3) 
png(filename = "../05.Analysis_in_R/3.Clustering/10 PCs Used/clustree0.5to0.9_umap.png", height = 6000, width = 10000, res = 300)
print(plot)
dev.off()
```
```{r clusterstability1, echo=TRUE, warning=TRUE}
data.use <- Embeddings(object = spatial_obj[["pca"]])
data.use <- data.use[, 1:18]    # number of PCs to use

seurat_clustering <- function(PC_matrix) {
    neighbor.graphs <- FindNeighbors(spatial_obj, dims = 1:18)
    clustering.results <- FindClusters(spatial_obj, verbose = FALSE)
    
    return(clustering.results$SCT_snn_res.0.6)
}

bootstrap_clusters <-  bluster::bootstrapStability(data.use, FUN = seurat_clustering, compare=NULL, mode="ratio", transposed = TRUE)

p <- bootstrap_clusters %>%
  as_tibble() %>%
  rownames_to_column(var = 'cluster_1') %>%
  pivot_longer(
    cols = 2:ncol(.),
    names_to = 'cluster_2',
    values_to = 'probability'
  ) %>%
  mutate(
    cluster_1 = as.character(as.numeric(cluster_1) - 1),
    cluster_1 = factor(cluster_1, levels = rev(unique(cluster_1))),
    cluster_2 = factor(cluster_2, levels = unique(cluster_2))
  ) %>%
  ggplot(aes(cluster_2, cluster_1, fill = probability)) +
  geom_tile(color = 'white') +
  geom_text(aes(label = round(probability, digits = 2)), size = 2.5) +
  scale_x_discrete(name = 'Cluster', position = 'top') +
  scale_y_discrete(name = 'Cluster') +
  scale_fill_gradient(
    name = 'Probability', low = 'white', high = '#c0392b', na.value = '#bdc3c7',
    limits = c(0,1),
    guide = guide_colorbar(
      frame.colour = 'black', ticks.colour = 'black', title.position = 'left',
      title.theme = element_text(hjust = 1, angle = 90),
      barwidth = 0.75, barheight = 10
    )
  ) +
  coord_fixed() +
  theme_bw() +
  theme( 
    legend.position = 'right',
    panel.grid.major = element_blank(),
    plot.title = element_text(hjust = 0.5)  # Center the title
  ) +
  ggtitle("Resolution 0.6 Cluster Stability")  # Add your title here
p
```

```{r clusterstability, echo=TRUE, warning=TRUE}
spatial.sce <- as.SingleCellExperiment(spatial_obj, assay = "SCT")
reducedDim(spatial.sce, 'PCA_sub') <- reducedDim(spatial.sce, 'PCA')[,1:18, drop = FALSE]

ass_prob <- bluster::bootstrapStability(spatial.sce, FUN = function(x) {
    g <- buildSNNGraph(x, use.dimred = 'PCA_sub')
    igraph::cluster_walktrap(g)$membership
  },
  clusters = spatial.sce$SCT_snn_res.0.8
)

p <- ass_prob %>%
  as_tibble() %>%
  rownames_to_column(var = 'cluster_1') %>%
  pivot_longer(
    cols = 2:ncol(.),
    names_to = 'cluster_2',
    values_to = 'probability'
  ) %>%
  mutate(
    cluster_1 = as.character(as.numeric(cluster_1) - 1),
    cluster_1 = factor(cluster_1, levels = rev(unique(cluster_1))),
    cluster_2 = factor(cluster_2, levels = unique(cluster_2))
  ) %>%
  ggplot(aes(cluster_2, cluster_1, fill = probability)) +
  geom_tile(color = 'white') +
  geom_text(aes(label = round(probability, digits = 2)), size = 2.5) +
  scale_x_discrete(name = 'Cluster', position = 'top') +
  scale_y_discrete(name = 'Cluster') +
  scale_fill_gradient(
    name = 'Probability', low = 'white', high = '#c0392b', na.value = '#bdc3c7',
    limits = c(0,1),
    guide = guide_colorbar(
      frame.colour = 'black', ticks.colour = 'black', title.position = 'left',
      title.theme = element_text(hjust = 1, angle = 90),
      barwidth = 0.75, barheight = 10
    )
  ) +
  coord_fixed() +
  theme_bw() +
  theme( 
    legend.position = 'right',
    panel.grid.major = element_blank(),
    plot.title = element_text(hjust = 0.5)  # Center the title
  ) +
  ggtitle("Resolution 0.8 Cluster Stability")  # Add your title here
p
```

```{r silhouette, echo=TRUE, warning=TRUE}

distance_matrix <- dist(Embeddings(spatial_obj[['pca']])[, 1:18])
clusters <- spatial_obj@meta.data$SCT_snn_res.0.9
silhouette <- silhouette(as.numeric(clusters), dist = distance_matrix)
spatial_obj@meta.data$silhouette_score <- silhouette[,3]

mean_silhouette_score <- mean(spatial_obj@meta.data$silhouette_score)

p <- spatial_obj@meta.data %>%
  mutate(barcode = rownames(.)) %>%
  arrange(SCT_snn_res.0.9,-silhouette_score) %>%
  mutate(barcode = factor(barcode, levels = barcode)) %>%
  ggplot() +
  geom_col(aes(barcode, silhouette_score, fill = SCT_snn_res.0.9), show.legend = TRUE) +
  geom_hline(yintercept = mean_silhouette_score, color = 'red', linetype = 'dashed') +
  scale_x_discrete(name = 'Cells') +
  scale_y_continuous(name = 'Silhouette score') +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    plot.title = element_text(hjust = 0.5)
  ) +
  ggtitle("Silhouette Scores by Resolution 0.9")
p
```




```{r modularity, echo=TRUE, warning=TRUE}
sce <- as.SingleCellExperiment(spatial_obj)

reducedDim(sce, 'PCA_sub') <- reducedDim(sce, 'PCA')[,1:18, drop = FALSE]

graph <- scran::buildSNNGraph(sce, use.dimred = 'PCA_sub')

ratio <- bluster::pairwiseModularity(graph, spatial_obj@meta.data$SCT_snn_res.0.9, as.ratio = TRUE)

ratio_to_plot <- log10(ratio+1)

p <- ratio_to_plot %>%
  as_tibble() %>%
  rownames_to_column(var = 'cluster_1') %>%
  pivot_longer(
    cols = 2:ncol(.),
    names_to = 'cluster_2',
    values_to = 'probability'
  ) %>%
  mutate(
    cluster_1 = as.character(as.numeric(cluster_1) - 1),
    cluster_1 = factor(cluster_1, levels = rev(unique(cluster_1))),
    cluster_2 = factor(cluster_2, levels = unique(cluster_2))
  ) %>%
  ggplot(aes(cluster_2, cluster_1, fill = probability)) +
  geom_tile(color = 'white') +
  geom_text(aes(label = round(probability, digits = 2)), size = 2.5) +
  scale_x_discrete(name = 'Cluster', position = 'top') +
  scale_y_discrete(name = 'Cluster') +
  scale_fill_gradient(
    name = 'log10(ratio)', low = 'white', high = '#c0392b', na.value = '#bdc3c7',
    guide = guide_colorbar(
      frame.colour = 'black', ticks.colour = 'black', title.position = 'left',
      title.theme = element_text(hjust = 1, angle = 90),
      barwidth = 0.75, barheight = 10
    )
  ) +
  coord_fixed() +
  theme_bw() +
  theme(
    legend.position = 'right',
    panel.grid.major = element_blank(),
    plot.title = element_text(hjust = 0.5)
  ) +
  ggtitle("Modularity Scores by Resolution 0.9")
p
```



```{r changeactiveident, echo=TRUE, warning=TRUE}
spatial_obj <- SetIdent(spatial_obj, value = spatial_obj@meta.data$SCT_snn_res.0.8)
```
```{r identityclasslabel, echo=TRUE, warning=TRUE}
table(Idents(spatial_obj))
```


## 6. LoupeR to Generate CLOUPE files from Seurat Objects

LoupeR is an R package designed to empower community tool users and developers to incorporate Loupe Browser for data exploration and collaboration. The package works with Seurat objects to create a .cloupe file. The .cloupe file can then be imported into Loupe Browser v7.0 for data visualization and further exploration. LoupeR makes it easy to explore:

- Data from a standard Seurat pipeline
- Data generated from advanced analysis that contains a count matrix, clustering, and projections

```{r loupeR, echo=TRUE, warning=TRUE}
library(loupeR)
resolution_to_remove <- c("SCT_snn_res.0", "SCT_snn_res.0.1", "SCT_snn_res.0.2", "SCT_snn_res.0.3", "SCT_snn_res.0.4", "SCT_snn_res.0.5", "SCT_snn_res.0.6",
                          "SCT_snn_res.0.7", "SCT_snn_res.0.9", "SCT_snn_res.1", "SCT_snn_res.1.1", "SCT_snn_res.1.2", "SCT_snn_res.1.3")
for (resolution_name in resolution_to_remove) {
  spatial_obj3@meta.data[[resolution_name]] <- NULL}
create_loupe_from_seurat(spatial_obj3, force = TRUE)
```


## 8. Gene Expression

# 8.1 Observing eGFP/mTomato Expression in Spatial Data

Our proposed work is possible because of our unique mouse model. Our lab developed a transgenic mouse model (Car1-Cre, CAC) that expresses Cre recombinase under the control of the mouse Car1 gene promoter that limits its expression to the large intestine where early-onset CRC is more prevalent. When crossed with ROSAmT/mG mouse, we were able to track Cre-mediated recombination at the ROSA allele by the switch from tomato red (normal) to eGFP labeling in colon epithelial cells. We found that Cre-mediated recombination occurs in ~6% of crypts with the expression reaching from the crypt base stem cells to the differentiated colonocytes at the luminal surface. By crossing this CACtg/tg-, ROSAmT/mG (CR) mouse with one (i.e., single APC allele deletion) or more (i.e., Apc + KrasG12D) oncogenic mutations, we were able to model sporadic CRC at various stages and easily visualize the normal cells (Tomato red +) and mutant or tumor cells (eGFP +). Our goal in this project is to identify the mechanisms or markers involved in the transition of normal tissue to cancer. Therefore, it is crucial to measure the proportion of eGFP vs mTomato expression in our spatial data and observe whether eGFP+ cells near or far from mTomato cells express different gene expression.


```{r gfp, echo=TRUE, fig.width=20 warning=TRUE}
plot34 <- SpatialFeaturePlot(spatial_obj3, features = c("eGFP"), ncol = 3)
png(filename = "../05.Analysis_in_R/rplot/spatialfeature_egfp.png", height = 6000, width = 5000, res = 300)
print(plot34)
dev.off()
```


```{r idk4, echo=TRUE, warning=TRUE}
spatial_539 <- SCTransform(spatial_obj, assay = "Spatial", ncells = 14799, residual.features = NULL, variable.features.n = 8332,  verbose = TRUE)
spatial_539 <- RunPCA(spatial_539, verbose = FALSE)


```
```{r idk5, echo=TRUE, warning=TRUE}
pct <- spatial_obj[["pca"]]@stdev / sum(spatial_obj[["pca"]]@stdev) * 100
cumu <- cumsum(pct)
co1 <- which(cumu > 90 & pct < 5)[1]
co1
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
pcs <- min(co1, co2)
pcs

```
```{r idk5, echo=TRUE, warning=TRUE}
```
```{r idk5, echo=TRUE, warning=TRUE}
```
```{r idk5, echo=TRUE, warning=TRUE}
```
```{r idk5, echo=TRUE, warning=TRUE}
```


