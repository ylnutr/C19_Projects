---
title: "Converting Human scRNA-seq data to Mouse scRNA-seq reference"
author: "Yujin L"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 0. Background and Information

## 0-1. Objective

My goal in this report is to create a single-cell reference data that I can utilize to annotate my own NGS data.

## 0-2. Data Source and Pre-processing

I will use a single-cell reference atlas of 260,506 cells from serial FFPE sections of normal and CRC human tissues (n = 8) from this paper that was recently published in nature genetics: 

The analysis utilized a single-cell reference atlas of 260,506 cells from serial Formalin-Fixed Paraffin-Embedded (FFPE) sections of normal and colorectal cancer (CRC) tissues (n=8). This dataset was generated and described in a recent *Nature Genetics* publication:

> Oliveira, M.F.d., Romero, J.P., Chung, M. et al. High-definition spatial transcriptomic profiling of immune cell populations in colorectal cancer. *Nat Genet* (2025). [https://doi.org/10.1038/s41588-025-02193-3](https://doi.org/10.1038/s41588-025-02193-3)

The raw count matrix was generated by aggregating multiple samples using the Cell Ranger `aggr` pipeline. The initial step involved loading this count matrix and its corresponding aggregation manifest into a `Seurat` object. The original study's cell-level annotations and UMAP coordinates were programmatically parsed and mapped to the correct cells to recreate the fully annotated reference object.

## 0-3. Human-to-Mouse Gene Ortholog Conversion

To enable comparative analysis with mouse models, the feature names (genes) of the Seurat object were converted from human to their mouse orthologs. This was achieved using a direct data file from the Mouse Genome Informatics (MGI) database at the Jackson Laboratory (JAX).

1.  **Data Retrieval:** The `HOM_MouseHumanSequence.rpt` file, containing human and mouse homology data, was downloaded from the JAX website (`www.informatics.jax.org`).

2.  **Ortholog Mapping:** The file was processed to create a comprehensive mapping table between human gene symbols (`HGNC`) and mouse gene symbols (`MGI`) based on shared database class keys.

3.  **Resolving Ambiguous Mappings:** The relationship between human and mouse orthologs was not exclusively one-to-one. To resolve these ambiguities while preserving the maximum amount of data, the following strategy was employed:
    * Mappings where multiple human genes corresponded to a **single mouse gene** were identified. The expression counts of these human genes were **summed** to create a single, consolidated expression value for the target mouse gene.
    * Mappings that were **unambiguous (one-to-one)** were retained for direct renaming.
    * Mappings where one human gene corresponded to multiple mouse genes were excluded to prevent ambiguity.

4.  **Object Creation:** A new count matrix with mouse gene symbols as feature names was constructed from the processed data. This final matrix was used to create a new `Seurat` object, `ColonCancer_Flex_Mouse`, while carrying over the original, unchanged cell-level metadata. The entire analysis pipeline, including normalization, scaling, and dimensionality reduction, was then re-run on this new object.

## 0-4. Data Export and Storage

Lastly, the final `ColonCancer_Flex_Mouse` Seurat object was exported for both visualization and future computational work. For interactive exploration, the `LoupeR` package was used to convert the object into the `.cloupe` file format, packaging the expression matrix, cluster assignments, and UMAP coordinates for use in the 10x Genomics Loupe Browser. For long-term storage and reproducibility, the final processed Seurat object was also serialized and saved as an `.rds` file using the base R function `saveRDS()`.

# 1. Load 

## 1-1. Set working directory

In this step, we verify and update the working directory to ensure that all subsequent file operations (e.g., reading or writing data) are performed in the correct project folder. This is particularly important for maintaining reproducibility and avoiding file path errors. The directory is set to the folder containing the results of the functional annotation analysis for spatial transcriptomics clusters.

```{r setwd, echo=TRUE, warning=TRUE}
getwd()
setwd("/stor/work/Fleet/BCG/2025_03.Fleet_scRNA-seq/04.Analysis in R/Convert_Human_to_Mouse_reference/")
getwd()
```

## 1-2. Load Packages

In this step, we load the essential R packages required for single-cell RNA-seq analysis and spatial annotation. The `Seurat` package provides a comprehensive toolkit for quality control, analysis, and exploration of single-cell data. `Azimuth` enables reference-based mapping of query datasets to annotated cell types. `BPCells` is used for efficient storage and manipulation of large single-cell datasets. Additionally, we source a custom script containing auxiliary functions (`AuxFunctions.R`) to support downstream analysis workflows.

```{r load, echo=TRUE, warning=TRUE}
## Load required Packages
library(Seurat)
library(Azimuth)
library(BPCells)
library(dplyr)
library(Matrix) # For sparse matrix operations
library(loupeR)
# Load Auxiliary Functions
source("/stor/work/Fleet/BCG/2025_03.Fleet_scRNA-seq/04.Analysis in R/Methods/AuxFunctions.R")
```

## 1-3. Load Aggregated dataset

In this step, we load the aggregated single-cell RNA-seq dataset generated by Cell Ranger into R as a Seurat v5 object. The dataset is stored in HDF5 format and read using `open_matrix_10x_hdf5()`. To facilitate downstream processing, the matrix is saved in a directory format using `write_matrix_dir()` and reloaded with `open_matrix_dir()`. Finally, gene identifiers are converted from Ensembl IDs to gene symbols using `ConvertEnsembleToSymbol()` for improved interpretability. This prepares the dataset for quality control and analysis.

```{r loaddataset, echo=TRUE, warning=TRUE}
# Read Aggr'd dataset as a Seurat V5 object
FlexOutPath <- "../Convert_Human_to_Mouse_reference/HumanReference/" # Path to cellranger aggr output folder
ColonFlex.data <- open_matrix_10x_hdf5(path = paste0(FlexOutPath,"HumanCRC_Flex_Multiplex_count_filtered_feature_bc_matrix.h5")) 
Flex.mat <- open_matrix_dir(dir = "../Convert_Human_to_Mouse_reference/HumanReference/Outputs/FlexSeurat/")
Flex.mat <- Azimuth:::ConvertEnsembleToSymbol(mat = Flex.mat, species = "human") 

# Read aggregation_csv.csv file to be used as MetaData ( Patient, etc)
MetaData<-read.csv(paste0(FlexOutPath,"HumanCRC_Flex_Multiplex_aggregation.csv"))
MetaData$Patient<-sapply(strsplit(MetaData$sample_id,"_"),function(X){return(X[6])})
MetaData$BC<-sapply(strsplit(MetaData$sample_id,"_"),function(X){return(X[7])})
MetaData$Condition<-gsub("P[0-9]","",MetaData$Patient)
Index<-as.numeric(sapply(strsplit(colnames(Flex.mat),"-"),function(X){return(X[2])}))
MetaData<-MetaData[Index,3:4]
MetaData$Barcode<-colnames(Flex.mat)
rownames(MetaData)<-MetaData$Barcode

# Cell Ranger Results
UMAP<-read.csv(paste0(FlexOutPath,"/analysis/umap/gene_expression_2_components/projection.csv"))
MetaData<-cbind(MetaData,UMAP[match(MetaData$Barcode,UMAP$Barcode),2:3])
```

# 2. Create and Processing Seurat Object

Now that the raw count matrix and the manually constructed metadata table are prepared, we will combine them to create a formal `Seurat` object. This object will serve as the container for all subsequent analysis steps.

```{r createseurat, echo=TRUE, warning=TRUE}
# Create Seurat Object
ColonCancer_Flex<-CreateSeuratObject(Flex.mat,meta.data = MetaData)
```

With the Seurat object created, the next critical step is to perform quality control (QC). We will calculate several QC metrics to identify and remove low-quality cells, such as those with high mitochondrial gene expression (indicating stress or apoptosis) or those with unusually low or high UMI/gene counts. This filtering ensures that our downstream analysis is based on viable, healthy cells.

```{r QC, echo=TRUE, warning=TRUE}
# Add % MT
ColonCancer_Flex[["MT.percent"]] <- PercentageFeatureSet(ColonCancer_Flex, pattern = "^MT-")

# Add UMAP projection
ColonCancer_Flex[["umap"]] <- CreateDimReducObject(embeddings = as.matrix(MetaData[,c("UMAP.1","UMAP.2")]), key = "UMAP_", assay = DefaultAssay(ColonCancer_Flex))

# UMI and Gene Threshold (by removing 5%)
UMI_TH<-quantile(ColonCancer_Flex$nCount_RNA,c(0.025,0.975))
Gene_TH<-quantile(ColonCancer_Flex$nFeature_RNA,c(0.025,0.975))

# Add variable with QC filter status
ColonCancer_Flex$QCFilter<-ifelse(ColonCancer_Flex$MT.percent < 25 & 
                                    ColonCancer_Flex$nCount_RNA > UMI_TH[1] & ColonCancer_Flex$nCount_RNA < UMI_TH[2] & 
                                    ColonCancer_Flex$nFeature_RNA > Gene_TH[1] & ColonCancer_Flex$nFeature_RNA < Gene_TH[2],"Keep","Remove")

# Remove bcs that failed QC
ColonCancer_Flex<-subset(ColonCancer_Flex,cells=colnames(ColonCancer_Flex)[ColonCancer_Flex$QCFilter=="Keep"])
```

After filtering out low-quality cells, we proceed with the core analysis using the Seurat v5 workflow. To handle this large dataset efficiently, we will first create a smaller, representative "sketch" of the data containing about 15% of the cells, selected using the `LeverageScore` method. All subsequent computationally intensive steps, such as `ScaleData` and `RunPCA`, will be performed on this sketch. This is followed by graph-based clustering to identify distinct cell populations.

```{r seurat processing, echo=TRUE, warning=TRUE}
# Seurat V5 Processing (We will sketch and then project) at ~ 15% of the full data
ColonCancer_Flex <- NormalizeData(ColonCancer_Flex)
ColonCancer_Flex <- FindVariableFeatures(ColonCancer_Flex)
ColonCancer_Flex <- SketchData(object = ColonCancer_Flex,ncells = 37000,
                               features = VariableFeatures(ColonCancer_Flex),
                               method = "LeverageScore",sketched.assay = "sketch")

DefaultAssay(ColonCancer_Flex) <- "sketch"
ColonCancer_Flex <- FindVariableFeatures(ColonCancer_Flex)
ColonCancer_Flex <- ScaleData(ColonCancer_Flex)
ColonCancer_Flex <- RunPCA(ColonCancer_Flex)
ElbowPlot(ColonCancer_Flex,ndims=40)
ColonCancer_Flex <- FindNeighbors(ColonCancer_Flex, dims = 1:25)
ColonCancer_Flex <- FindClusters(ColonCancer_Flex, resolution = 0.6)
```

he object has now been processed and clustered based on its gene expression profiles. To interpret these clusters biologically, we will now load and add a detailed, pre-existing metadata file (**SingleCell_MetaData.csv**). This file contains high-quality cell type annotations (e.g., Level1 and Level2 labels), which we will merge into our Seurat object. This allows us to assign a biological identity to the clusters we have identified.

```{r addmetadata, echo=TRUE, warning=TRUE}
# 1. Read the metadata from your CSV file into a data frame
metadata <- read.csv("./HumanReference/SingleCell_MetaData.csv")

# 2. Set the row names of the metadata data frame to be the cell barcodes.
#    This is a crucial step for Seurat to match the metadata to the correct cells.
rownames(metadata) <- metadata$Barcode

# 3. Add the metadata to your Seurat object.
#    Seurat will automatically align the data based on the cell names.
ColonCancer_Flex <- AddMetaData(
  object = ColonCancer_Flex,
  metadata = metadata
)

# 4. (Optional but recommended) Verify that the new metadata has been added.
#    You should see the new columns (Patient, Level1, Level2, etc.) at the end.
head(ColonCancer_Flex@meta.data)
# Remove overlapping metadata. Here, we remove UMAP1, UMAP2, and sketch_snn_res.0.6
ColonCancer_Flex$UMAP1 <- NULL
ColonCancer_Flex$UMAP2 <- NULL
ColonCancer_Flex$sketch_snn_res.0.6 <- NULL
# Check if the columns are deleted correctly
head(ColonCancer_Flex@meta.data)
```

Finally, with the analysis complete and cell type annotations loaded, we will visualize the results. We will generate UMAP plots to display the cellular landscape, coloring the cells by their Level1 (broad) and Level2 (detailed) annotations. These plots provide an intuitive overview of the cell type composition and their relationships within the tissue, and they will be saved as high-resolution images for inclusion in reports.

```{r UMAP, echo=TRUE, warning=TRUE}
p1 <- DimPlot(ColonCancer_Flex, label = T, label.size = 6, 
              reduction = "umap",  group.by = "Level1", raster = FALSE)
p1
png(filename = "../Convert_Human_to_Mouse_reference/plots/lvl1_umap.png", height = 3600, width = 4800, res = 300)
print(p1)
dev.off()
p2 <- DimPlot(ColonCancer_Flex, label = T, label.size = 4, 
        reduction = "umap",  group.by = "Level2", raster = FALSE)
p2
png(filename = "../Convert_Human_to_Mouse_reference/plots/lvl2_umap.png", height = 3600, width = 5800, res = 300)
print(p2)
dev.off()
```

![Level 1 UMAP]("../Convert_Human_to_Mouse_reference/plots/lvl2_umap.png")

![Level 2 UMAP]("../Convert_Human_to_Mouse_reference/plots/lvl2_umap.png")

# 3. Create Human-Mouse Gene Symbol Conversion List

In this step, we first download the complete human-mouse homology report directly from the Mouse Genome Informatics (MGI) database provided by the Jackson Laboratory (JAX). This file serves as our primary source for mapping genes between the two species. Next, we clean human and mouse gene tables and merge two tables by their shared **DB.Class.Key**. The resulting data frame, mh_data, provides a direct link where each row ideally connects a human gene symbol to its corresponding mouse ortholog, which will be used in the next step to convert our dataset.

```{r convert, echo=TRUE, warning=TRUE}
cat("Downloading gene homology data from MGI/JAX...\n")
# Download the data file once and store it in a data frame
# This file contains ortholog information for various species
mouse_human_genes <- read.csv("https://www.informatics.jax.org/downloads/reports/HOM_MouseHumanSequence.rpt", sep = "\t")

# separate human and mouse 
mouse <- split.data.frame(mouse_human_genes,mouse_human_genes$Common.Organism.Name)[[2]]
human <- split.data.frame(mouse_human_genes,mouse_human_genes$Common.Organism.Name)[[1]]

# remove some columns
mouse <- mouse[,c(1,4)]
human <- human[,c(1,4)]

# merge the 2 dataset  (note that the human list is longer than the mouse one)
mh_data <- merge.data.frame(mouse,human,by = "DB.Class.Key",all.y = TRUE) 

# Modification: Rename the confusing 'Symbol.x' and 'Symbol.y' columns for clarity
colnames(mh_data) <- c("DB.Class.Key", "mouse_symbol", "human_symbol")

# Verify the structure of the final mapping table
head(mh_data)
```

# 4. Applying the Gene Conversion Map to the Seurat Object

With the **mh_data** conversion map created, the next step is to apply it to our **ColonCancer_Flex** Seurat object. A direct renaming is not possible because, as is common in cross-species orthology, the gene mappings are not exclusively one-to-one. A naive conversion would lead to duplicate mouse gene names and cause an error.

Therefore, we first analyze the map to identify and separate the unambiguous one-to-one mappings from the ambiguous many-to-one mappings. This allows us to handle each case appropriately.

## 4-1. Duplicate Identification

```{r humangenelistconvert, echo=TRUE, warning=TRUE}
# Get the list of human genes from your Seurat object
human_genes_in_seurat <- rownames(ColonCancer_Flex[["RNA"]])
print(paste("Found", length(human_genes_in_seurat), "human genes to convert."))
human_genes_in_seurat[1:100]

# Filter the original count matrix to only include genes we can successfully map
mappable_genes <- intersect(human_genes_in_seurat, mh_data$human_symbol)
original_counts <- GetAssayData(ColonCancer_Flex, assay = "RNA", layer = "counts")
counts_filtered <- original_counts[mappable_genes, ]

# Create a look-up vector for renaming (human_symbol -> mouse_symbol)
rename_vector <- setNames(mh_data$mouse_symbol, mh_data$human_symbol)

# Get the new mouse gene names in the correct order
new_rownames <- rename_vector[rownames(counts_filtered)]

# Rename the rows of the filtered matrix
rownames(counts_filtered) <- new_rownames
```

Because the relationship between human and mouse orthologs is not always one-to-one, the direct renaming approach above is likely to create duplicate entries. We need to analyze the **new_rownames** vector to identify and count any mouse gene symbols that appear more than once. This step is crucial for diagnosing the extent of the issue.

```{r dupcheck, echo=TRUE, warning=TRUE}
cat("Finding duplicate gene symbols within the 'new_rownames' vector...\n")

# Step 1: Use the table() function to count the frequency of each gene name
name_counts <- table(new_rownames)

# Step 2: Filter this table to find names that appear more than once
# A frequency > 1 means the gene name is a duplicate.
duplicate_names <- names(name_counts[name_counts > 1])

if (length(duplicate_names) > 0) {
  cat("The following", length(duplicate_names), "mouse gene symbols were duplicates:\n")

  # To see the full details, let's look at the original frequency table for these specific genes
  print(name_counts[duplicate_names])

} else {
  cat("No duplicate gene symbols were found in 'new_rownames'.\n")
}
```
## 4-2. Resolving Duplicates by Summing Expression

The check above confirms that a significant number of duplicates were generated. To proceed, we must resolve these ambiguities. Instead of discarding this valuable data, the chosen strategy is to sum the expression counts of all human genes that map to the same mouse ortholog.

First, we will sort our full gene map to two groups, separating the unambiguous one-to-one mappings from the ambiguous many-to-one mappings, which require summation.

```{r separateuniquevsdup, echo=TRUE, warning=TRUE}

# Modification: Add logic to identify and separate unique vs. duplicate mappings
# Find which mouse genes are targets of multiple human genes
mouse_duplicates <- mh_data$mouse_symbol[duplicated(mh_data$mouse_symbol) | duplicated(mh_data$mouse_symbol, fromLast = TRUE)]
mouse_duplicates <- unique(mouse_duplicates)

# A) Get the clean, one-to-one mappings
map_unique <- mh_data %>%
  filter(!mouse_symbol %in% mouse_duplicates) %>%
  # Also remove human genes that map to multiple mouse genes
  group_by(human_symbol) %>%
  filter(n() == 1) %>%
  ungroup()

# B) Get the ambiguous, many-to-one mappings that we need to sum
map_duplicates <- mh_data %>%
  filter(mouse_symbol %in% mouse_duplicates)

cat(paste(nrow(map_unique), "genes have a 1-to-1 mapping.\n"))
cat(paste(n_distinct(map_duplicates$mouse_symbol), "mouse genes will be created by summing the counts of", nrow(map_duplicates), "human genes.\n"))
```

For the genes with a clear one-to-one relationship, we simply rename them. For the ambiguous cases, we sum the counts. These two sets of counts are then combined and used to create the final **ColonCancer_Flex_Mouse** Seurat object, which will have unique feature names and preserve the maximum amount of biological data.

```{r sum, echo=TRUE, warning=TRUE}
# Get the original count matrix from your Seurat object
original_counts <- GetAssayData(ColonCancer_Flex, assay = "RNA", layer = "counts")

# A) Process the 1-to-1 mapped genes (filter and rename)
counts_unique <- original_counts[rownames(original_counts) %in% map_unique$human_symbol, ]
rename_vector_unique <- setNames(map_unique$mouse_symbol, map_unique$human_symbol)
rownames(counts_unique) <- rename_vector_unique[rownames(counts_unique)]

# B) Process the many-to-one mapped genes (summation)
# Split the duplicate map into a list, where each element is a group of human genes
# that map to the same mouse gene.
list_of_duplicates <- split(map_duplicates$human_symbol, map_duplicates$mouse_symbol)

# Use lapply to iterate through this list, sum the counts, and return a list of matrices
summed_counts_list <- lapply(list_of_duplicates, function(human_genes_to_sum) {
  # Get the counts for the human genes in this group that exist in your data
  genes_present <- intersect(human_genes_to_sum, rownames(original_counts))
  if (length(genes_present) == 0) return(NULL) # Skip if no genes from this group are in the data
  
  counts_to_sum <- original_counts[genes_present, , drop = FALSE]
  return(Matrix::colSums(counts_to_sum))
})

# Combine the results into a single matrix.
counts_summed <- do.call(rbind, summed_counts_list)

# Convert the standard 'counts_summed' matrix into a sparse matrix.
counts_summed_sparse <- Matrix(counts_summed, sparse = TRUE)

# Now, combine the two matrices, which are both in the sparse format
final_mouse_counts <- rbind(counts_unique, counts_summed_sparse)

cat("\nCreating final Seurat object with resolved duplicates...\n")
ColonCancer_Flex_Mouse <- CreateSeuratObject(
  counts = final_mouse_counts,
  meta.data = ColonCancer_Flex@meta.data # Copy over your existing cell metadata
)

# This will now succeed
print("Successfully created new Seurat object.")
print(ColonCancer_Flex_Mouse)
```

# 5. Downstream Analysis of the Mouse-Gene Seurat Object

With the **ColonCancer_Flex_Mouse** object successfully created, the next stage is to perform a full downstream analysis. This involves normalizing the data, identifying variable features, running dimensionality reduction, and performing cell clustering, all based on the new mouse gene expression profiles.

Before beginning the new analysis pipeline, we will first add the UMAP coordinates from the original human-gene-based analysis back into the object as a dimensional reduction slot named umap. This allows us to later visualize our new mouse-gene-based clusters on the original UMAP layout for comparative purposes. 

```{r mousedataprocessing, echo=TRUE, warning=TRUE}
# Add UMAP projection
ColonCancer_Flex_Mouse[["umap"]] <- CreateDimReducObject(embeddings = as.matrix(ColonCancer_Flex_Mouse@meta.data[,c("UMAP.1","UMAP.2")]), key = "UMAP_", assay = DefaultAssay(ColonCancer_Flex_Mouse))

# leverage.score from the human seurat data is already existed in the meta.data.Remove leverage.score so we can generate a correct score for mouse data.
ColonCancer_Flex_Mouse$leverage.score <- NULL

# Seurat V5 Processing (We will sketch and then project) at ~ 15% of the full data
ColonCancer_Flex_Mouse <- NormalizeData(ColonCancer_Flex_Mouse)
ColonCancer_Flex_Mouse <- FindVariableFeatures(ColonCancer_Flex_Mouse)
ColonCancer_Flex_Mouse <- SketchData(object = ColonCancer_Flex_Mouse,ncells = 37000,
                               features = VariableFeatures(ColonCancer_Flex_Mouse),
                               method = "LeverageScore",sketched.assay = "sketch")

DefaultAssay(ColonCancer_Flex_Mouse) <- "sketch"
ColonCancer_Flex_Mouse <- FindVariableFeatures(ColonCancer_Flex_Mouse)
ColonCancer_Flex_Mouse <- ScaleData(ColonCancer_Flex_Mouse)
ColonCancer_Flex_Mouse <- RunPCA(ColonCancer_Flex_Mouse)
ElbowPlot(ColonCancer_Flex_Mouse,ndims=40)
ColonCancer_Flex_Mouse <- FindNeighbors(ColonCancer_Flex_Mouse, dims = 1:25)
ColonCancer_Flex_Mouse <- FindClusters(ColonCancer_Flex_Mouse, resolution = 0.6)
```

Now that new cell clusters have been identified based on the mouse gene expression data, the final step is to visualize these results. We will generate UMAP plots, coloring the cells according to their high-quality Level1 and Level2 annotations. By plotting on the original UMAP reduction, we can effectively compare how the new, mouse-gene-based clusters are distributed across the cellular landscape that was defined by the original human gene set. These visualizations are then saved as high-resolution images.

```{r mouseUMAP, echo=TRUE, warning=TRUE}
p1 <- DimPlot(ColonCancer_Flex_Mouse, label = T, label.size = 6, 
              reduction = "umap",  group.by = "Level1", raster = FALSE)
p1
png(filename = "../Convert_Human_to_Mouse_reference/plots/mouseortholog_lvl1_umap.png", height = 3600, width = 4800, res = 300)
print(p1)
dev.off()
p2 <- DimPlot(ColonCancer_Flex_Mouse, label = T, label.size = 4, 
        reduction = "umap",  group.by = "Level2", raster = FALSE)
p2
png(filename = "../Convert_Human_to_Mouse_reference/plots/mouseortholog_lvl2_umap.png", height = 3600, width = 5800, res = 300)
print(p2)
dev.off()
```

![Level 1 UMAP]("../Convert_Human_to_Mouse_reference/plots/mouseortholog_lvl1_umap.png")

![Level 2 UMAP]("../Convert_Human_to_Mouse_reference/plots/mouseortholog_lvl2_umap.png")

# 6. Exporting Seurat Objects for Loupe Browser Visualization

The final step of this workflow is to export the processed Seurat objects into the .cloupe file format, which is required for interactive data exploration in the 10x Genomics Loupe Browser. This process was performed for both the newly created **ColonCancer_Flex_Mouse** object and the original **ColonCancer_Flex** object to facilitate a direct comparison between the analyses based on mouse versus human gene symbols.

## 6-1. Exporting the Mouse-Gene Object

Before conversion, the object must be prepared to meet the strict input requirements of the `LoupeR` package. First, we verify the class of the count matrix within the Seurat object. As a result of previous data manipulations, the matrix may not be in the required dgCMatrix sparse format. The script explicitly converts the matrix to this format to ensure compatibility. Following this, several intermediate metadata columns are removed to streamline the final Loupe file, and the default assay is set to RNA. The cleaned object is then processed by `create_loupe_from_seurat` to generate the final output file.

```{r checkmatrix, echo=TRUE, warning=TRUE}
# Step 1: Check the current class of your count matrix (optional, for confirmation)
# It is likely not a 'dgCMatrix' right now
cat("Current matrix class is:", class(ColonCancer_Flex_Mouse@assays$RNA@layers$counts), "\n")

# Step 2: Extract the matrix, convert it to the required dgCMatrix class,
# and put it back into the Seurat object.

counts_mat <- GetAssayData(ColonCancer_Flex_Mouse, assay = "RNA", layer = "counts")
counts_dgc <- as(counts_mat, "dgCMatrix")
ColonCancer_Flex_Mouse@assays$RNA@layers$counts <- counts_dgc

# Step 3: Verify the class has changed
cat("New matrix class is:", class(ColonCancer_Flex_Mouse@assays$RNA@layers$counts), "\n")

# Check the metadata before conversion
head(ColonCancer_Flex_Mouse@meta.data)
# Trim unnecessary metadata before converting
ColonCancer_Flex_Mouse$sketch_snn_res.0.6 <- NULL
ColonCancer_Flex_Mouse$QCFilter <- NULL
ColonCancer_Flex_Mouse$leverage.score <- NULL
ColonCancer_Flex_Mouse$Barcode <- NULL
ColonCancer_Flex_Mouse$seurat_clusters <- NULL

# Change default assay back to RNA
DefaultAssay(ColonCancer_Flex_Mouse) <- "RNA"
Idents(object = ColonCancer_Flex_Mouse) <- "Level2"
# convert the SeuratObject named `seurat_obj` to a Loupe file
create_loupe_from_seurat(ColonCancer_Flex_Mouse, output_name = "colon_cancer_mouse_genes")
```

## 6-2. Exporting the Original Human-Gene Object

For comparative purposes, the same export process is applied to the original **ColonCancer_Flex** object. 

```{r converthumantocloupe, echo=TRUE, warning=TRUE}
# Step 1: Check the current class of your count matrix (optional, for confirmation)
# It is likely not a 'dgCMatrix' right now
cat("Current matrix class is:", class(ColonCancer_Flex@assays$RNA@layers$counts), "\n")

# Step 2: Extract the matrix, convert it to the required dgCMatrix class,
# and put it back into the Seurat object.

counts_mat <- GetAssayData(ColonCancer_Flex, assay = "RNA", layer = "counts")
counts_dgc <- as(counts_mat, "dgCMatrix")
ColonCancer_Flex@assays$RNA@layers$counts <- counts_dgc

# Step 3: Verify the class has changed
cat("New matrix class is:", class(ColonCancer_Flex@assays$RNA@layers$counts), "\n")

# Check the metadata before conversion
head(ColonCancer_Flex@meta.data)
# Trim unnecessary metadata before converting
ColonCancer_Flex$sketch_snn_res.0.6 <- NULL
ColonCancer_Flex$QCFilter <- NULL
ColonCancer_Flex$leverage.score <- NULL
ColonCancer_Flex$Barcode <- NULL
ColonCancer_Flex$seurat_clusters <- NULL

# Change default assay back to RNA
DefaultAssay(ColonCancer_Flex) <- "RNA"
Idents(object = ColonCancer_Flex) <- "Level2"
# convert the SeuratObject named `seurat_obj` to a Loupe file
create_loupe_from_seurat(ColonCancer_Flex, output_name = "colon_cancer_human_genes")
```

# 7. Saving Final Seurat Objects

The final step in the data processing workflow is to save the two primary Seurat objects for future use. Serializing these large objects into `.rds` files allows for quick reloading into new R sessions without the need to repeat the time-consuming processing and conversion steps. This ensures that the exact state of the objects at the end of this analysis is preserved for reproducibility and downstream applications.

```{r saveseuratobj, echo=TRUE, warning=TRUE}
# Save the object with mouse gene names
cat("Saving the mouse-gene Seurat object...\n")
saveRDS(ColonCancer_Flex_Mouse, file = "./ColonCancer_Flex_Mouse.rds")

# Save the original object with human gene names for reference
cat("Saving the human-gene Seurat object...\n")
saveRDS(ColonCancer_Flex, file = "./ColonCancer_Flex_Human.rds")

cat("\nWorkflow complete. All objects have been saved.\n")
```

```{r sessioninfo, echo=TRUE, warning=TRUE}
sessionInfo()
```